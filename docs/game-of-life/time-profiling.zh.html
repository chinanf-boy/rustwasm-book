<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>时间 分析 - Rust 和 WebAssembly</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="立即开始学习如何一起使用 Rust 和 WebAssembly.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="../introduction.zh.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li><a href="../why-rust-and-webassembly.zh.html"><strong aria-hidden="true">2.</strong> 为啥 Rust 要与 WebAssembly 合作?</a></li><li><a href="../background-and-concepts.zh.html"><strong aria-hidden="true">3.</strong> 背景和概念</a></li><li><ol class="section"><li><a href="../what-is-webassembly.zh.html"><strong aria-hidden="true">3.1.</strong> 什么是 WebAssembly?</a></li><li class="spacer"></li></ol></li><li><a href="../game-of-life/introduction.zh.html"><strong aria-hidden="true">4.</strong> 教程</a></li><li><ol class="section"><li><a href="../game-of-life/setup.zh.html"><strong aria-hidden="true">4.1.</strong> 安装</a></li><li><a href="../game-of-life/hello-world.zh.html"><strong aria-hidden="true">4.2.</strong> Hello, World!</a></li><li><a href="../game-of-life/rules.zh.html"><strong aria-hidden="true">4.3.</strong> 规则们</a></li><li><a href="../game-of-life/implementing.zh.html"><strong aria-hidden="true">4.4.</strong> 实现康威的生命游戏</a></li><li><a href="../game-of-life/testing.zh.html"><strong aria-hidden="true">4.5.</strong> 测试 生命</a></li><li><a href="../game-of-life/debugging.zh.html"><strong aria-hidden="true">4.6.</strong> 调试</a></li><li><a href="../game-of-life/interactivity.zh.html"><strong aria-hidden="true">4.7.</strong> 添加 交互性</a></li><li><a href="../game-of-life/time-profiling.zh.html" class="active"><strong aria-hidden="true">4.8.</strong> 时间 分析</a></li><li><a href="../game-of-life/code-size.zh.html"><strong aria-hidden="true">4.9.</strong> 收缩 .wasm 尺寸</a></li><li><a href="../game-of-life/publishing-to-npm.zh.html"><strong aria-hidden="true">4.10.</strong> 发布到 npm</a></li><li class="spacer"></li></ol></li><li><a href="../reference/index.zh.html"><strong aria-hidden="true">5.</strong> 参考</a></li><li><ol class="section"><li><a href="../reference/crates.zh.html"><strong aria-hidden="true">5.1.</strong> 你应该知道的 Crates(箱) </a></li><li><a href="../reference/tools.zh.html"><strong aria-hidden="true">5.2.</strong> 你应该知道的 工具 </a></li><li><a href="../reference/project-templates.zh.html"><strong aria-hidden="true">5.3.</strong> 项目模版 Templates</a></li><li><a href="../reference/debugging.zh.html"><strong aria-hidden="true">5.4.</strong> 调试</a></li><li><a href="../reference/time-profiling.zh.html"><strong aria-hidden="true">5.5.</strong> 时间 分析</a></li><li><a href="../reference/code-size.zh.html"><strong aria-hidden="true">5.6.</strong> 收缩 .wasm 尺寸</a></li><li><a href="../reference/js-ffi.zh.html"><strong aria-hidden="true">5.7.</strong> javascript 互操作</a></li><li><a href="../reference/which-crates-work-with-wasm.zh.html"><strong aria-hidden="true">5.8.</strong> 哪些 现成的(crates)箱能与 WebAssembly 合作？</a></li><li><a href="../reference/add-wasm-support-to-crate.zh.html"><strong aria-hidden="true">5.9.</strong> 如何向通用 箱 添加 WebAssembly 支持</a></li><li><a href="../reference/deploying-to-production.zh.html"><strong aria-hidden="true">5.10.</strong> 将 Rust 和 Webassembly 部署到生产中</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust 和 WebAssembly</h1> 

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#a时间分析" id="a时间分析"><h1>时间分析</h1></a>
<p>在本章中，我们将改进 Game of Life 实现的性能。我们将使用时间分析来指导我们的工作。</p>
<p>继续之前，自己熟悉下<a href="../reference/time-profiling.zh.html">时间分析 Rust 和 WebAssembly 代码的可用工具</a>。</p>
<a class="header" href="#a使用windowperformancenow函数创建秒数时间器" id="a使用windowperformancenow函数创建秒数时间器"><h2>使用<code>window.performance.now</code>函数，创建秒数时间器</h2></a>
<p>当我们研究如何加速我们的生命游戏渲染时，这个 FPS 计时器将非常有用。</p>
<p>我们首先添加一个<code>fps</code>对象到<code>wasm-game-of-life/www/index.js</code>：</p>
<pre><code class="language-js">const fps = new class {
  constructor() {
    this.fps = document.getElementById('fps');
    this.frames = [];
    this.lastFrameTimeStamp = performance.now();
  }

  render() {
    // Convert the delta time since the last frame render into a measure
    // of frames per second.
    const now = performance.now();
    const delta = now - this.lastFrameTimeStamp;
    this.lastFrameTimeStamp = now;
    const fps = (1 / delta) * 1000;

    // Save only the latest 100 timings.
    this.frames.push(fps);
    if (this.frames.length &gt; 100) {
      this.frames.shift();
    }

    // Find the max, min, and mean of our 100 latest timings.
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    for (let i = 0; i &lt; this.frames.length; i++) {
      sum += this.frames[i];
      min = Math.min(this.frames[i], min);
      max = Math.max(this.frames[i], max);
    }
    let mean = sum / this.frames.length;

    // Render the statistics.
    this.fps.textContent = `
Frames per Second:
         latest = ${Math.round(fps)}
avg of last 100 = ${Math.round(mean)}
min of last 100 = ${Math.round(min)}
max of last 100 = ${Math.round(max)}
`.trim();
  }
}();
</code></pre>
<p>接着，在每次<code>renderLoop</code>迭代时，我们调用给<code>fps</code> <code>render</code>函数：</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  fps.render(); //新

  universe.tick();
  drawGrid();
  drawCells();

  animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>最后，别忘了添加<code>fps</code>元素到<code>wasm-game-of-life/www/index.html</code>，就在<code>&lt;canvas&gt;</code>上面：</p>
<pre><code class="language-html">&lt;div id=&quot;fps&quot;&gt;&lt;/div&gt;
</code></pre>
<p>并添加更好的 CSS 其格式：</p>
<pre><code class="language-css">#fps {
  white-space: pre;
  font-family: monospace;
}
</code></pre>
<p>瞧！刷新<a href="http://localhost:8080">http://localhost:8080</a>，现在我们有一个 FPS 计数器！</p>
<a class="header" href="#a用consoletime和consoletimeend计时每个universetick" id="a用consoletime和consoletimeend计时每个universetick"><h3>用<code>console.time</code>和<code>console.timeEnd</code>计时每个<code>Universe::tick</code></h3></a>
<p>需要测量每次<code>Universe::tick</code>调用的时间，我们可以使用<code>console.time</code>和<code>console.timeEnd</code>，通过<code>web-sys</code>箱。</p>
<p>首先，在<code>wasm-game-of-life/Cargo.toml</code>添加<code>web-sys</code>作为依赖：</p>
<pre><code class="language-toml">[dependencies.web-sys]
version = &quot;0.3&quot;
features = [
  &quot;console&quot;,
]
</code></pre>
<p>因为每个<code>console.time</code>调用都应该有一个对应的<code>console.timeEnd</code>调用，方便将它们包装为一个<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a>类型：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate web_sys;
use web_sys::console;

pub struct Timer&lt;'a&gt; {
    name: &amp;'a str,
}

impl&lt;'a&gt; Timer&lt;'a&gt; {
    pub fn new(name: &amp;'a str) -&gt; Timer&lt;'a&gt; {
        console::time_with_label(name);
        Timer { name }
    }
}

impl&lt;'a&gt; Drop for Timer&lt;'a&gt; {
    fn drop(&amp;mut self) {
        console::time_end_with_label(self.name);
    }
}
#}</code></pre></pre>
<p>然后，将此代码段添加到方法的顶部，我们就可以计算每个<code>Universe::tick</code>时间：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let _timer = Timer::new(&quot;Universe::tick&quot;);
#}</code></pre></pre>
<p>每次<code>Universe::tick</code>调用的时间，现在会在控制台上记录了：</p>
<p><a href="../images/game-of-life/console-time.png"><img src="../images/game-of-life/console-time.png" alt="Screenshot of console.time logs" /></a></p>
<p>另外，一对<code>console.time</code>和<code>console.timeEnd</code>将显示在浏览器分析器的“时间轴”或“瀑布”视图中：pp<a href="../images/game-of-life/console-time-in-profiler.png"><img src="../images/game-of-life/console-time-in-profiler.png" alt="Screenshot of console.time logs" /></a></p>
<a class="header" href="#a壮大我们的生命游戏宇宙" id="a壮大我们的生命游戏宇宙"><h2>壮大我们的生命游戏宇宙</h2></a>
<blockquote>
<p>⚠️ 本节使用 Firefox 的示例屏幕截图。虽然所有现代浏览器都有类似的工具，但使用不同的开发人员工具可能会有轻微的细微差别。您提取的配置信息基本相同，但在您使用途中，可能会因您看到的视图和不同工具的命名而有所不同。</p>
</blockquote>
<p>如果我们让我们的生命游戏世界更大，会发生什么？用 128 x 128 宇宙替换 64 x 64 宇宙（通过修改<code>Universe::new</code>在<code>wasm-game-of-life/src/lib.rs</code>）导致 FPS 在我的机器上从平滑的 60 下降到波动的 40-ish。</p>
<p>如果我们记录一个配置文件(profile)并查看瀑布视图，我们会看到每个动画帧花费超过 20 毫秒。回想一下，每秒 60 帧的意思是，渲染帧的整个过程最多 16 毫秒。其中不仅仅是我们的 JavaScript 和 WebAssembly，还有浏览器正在做的其他事情，比如绘画。</p>
<p><a href="../images/game-of-life/drawCells-before-waterfall.png"><img src="../images/game-of-life/drawCells-before-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame" /></a></p>
<p>如果我们看一下单个动画帧中发生的事情，我们就会看到<code>CanvasRenderingContext2D.fillStyle</code>setter 很贵！</p>
<blockquote>
<p>⚠️ 在 Firefox 中，如果你看到一行简单地说“DOM”而不是上诉的<code>CanvasRenderingContext2D.fillStyle</code>，您可能需要在性能开发人员工具选项中打开“显示 Gecko 平台数据”选项：</p>
<p><a href="../images/game-of-life/profiler-firefox-show-gecko-platform.png"><img src="../images/game-of-life/profiler-firefox-show-gecko-platform.png" alt="Turning on Show Gecko Platform Data" /></a></p>
</blockquote>
<p><a href="../images/game-of-life/drawCells-before-flamegraph.png"><img src="../images/game-of-life/drawCells-before-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>我们可以通过查看调用树的多个帧的聚合，来确认这不是异常：</p>
<p><a href="../images/game-of-life/drawCells-before-calltree.png"><img src="../images/game-of-life/drawCells-before-calltree.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>我们将近 40％的时间花在了这个 setter 上！</p>
<blockquote>
<p>⚡ 我们可能会想这个<code>tick</code>方法是性能瓶颈，但事实并非如此。要让分析引导您的注意力，不然时间可能花在您不期望的地方。</p>
</blockquote>
<p><code>wasm-game-of-life/www/index.js</code>的<code>drawCells</code>函数里面，对每次动画帧，Universe 中的每个单元格都设置一次<code>fillStyle</code>属性：</p>
<pre><code class="language-js">for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);

    ctx.fillStyle = cells[idx] === DEAD ? DEAD_COLOR : ALIVE_COLOR;

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>现在我们已经发现了这个<code>fillStyle</code>是如此昂贵，我们可以做些什么来避免经常设置它？我们需要改变<code>fillStyle</code>，表明单元格是活着还是死亡。如果我们设定<code>fillStyle = ALIVE_COLOR</code>，然后在一次通过，绘制完所有活单元格，然后设置<code>fillStyle = DEAD_COLOR</code>，并在另一次，绘制所有死单元格，然后到结束，我们只设置了<code>fillStyle</code>两次，而不是单元格数。</p>
<pre><code class="language-js">// Alive cells.
ctx.fillStyle = ALIVE_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Alive) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}

// Dead cells.
ctx.fillStyle = DEAD_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Dead) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>保存这些更改，并刷新<a href="http://localhost:8080/">http://localhost:8080 /</a>后，渲染恢复到每秒平滑 60 帧。</p>
<p>如果我们采用另一个配置文件，我们可以看到现在每个动画帧只花费大约 10 毫秒。</p>
<p><a href="../images/game-of-life/drawCells-after-waterfall.png"><img src="../images/game-of-life/drawCells-after-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame after the drawCells changes" /></a></p>
<p>击败罪魁祸首，我们看到了<code>fillStyle</code>成本已经消失，我们的大部分时间花在了内部的<code>fillRect</code>，其是绘制每个单元格的矩形。</p>
<p><a href="../images/game-of-life/drawCells-after-flamegraph.png"><img src="../images/game-of-life/drawCells-after-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame after the drawCells changes" /></a></p>
<a class="header" href="#a让时间更快" id="a让时间更快"><h2>让时间更快</h2></a>
<p>有些人不喜欢等待，并且，如果每个动画帧不是发生仅一次宇宙嘀嗒(tick)，而是更喜欢九次。我们可以修改<code>wasm-game-of-life/www/index.js</code>的<code>renderLoop</code>函数，这很容易做到这一点：</p>
<pre><code class="language-js">for (let i = 0; i &lt; 9; i++) {
  universe.tick();
}
</code></pre>
<p>在我的机器上，这使我们恢复到每秒 35 帧。不好。我们想要那个大大滴 60！</p>
<p>现在我们知道时间花在了<code>Universe::tick</code>，所以让我们添加一些<code>Timer</code>，用<code>console.time</code>和<code>console.timeEnd</code>调用来包装它的各个部分，然后，看看它引导我们的地方。我假设啊，是分配一个新的单元格向量(vector)，后在每次 tick，就要释放旧向量是昂贵的，占用了我们时间预算的很大一部分。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn tick(&amp;mut self) {
    let _timer = Timer::new(&quot;Universe::tick&quot;);

    let mut next = {
        let _timer = Timer::new(&quot;allocate next cells&quot;);
        self.cells.clone()
    };

    {
        let _timer = Timer::new(&quot;new generation&quot;);
        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }
    }

    let _timer = Timer::new(&quot;free old cells&quot;);
    self.cells = next;
}
#}</code></pre></pre>
<p>看看时间，很明显我的假设是不正确的：绝大部分时间，实际花在计算下一代单元格上。令人惊讶的是，在每次 tick 上分配和释放向量，似乎具有可忽略的成本。分析记录是始终指导我们工作的提醒！</p>
<p><a href="../images/game-of-life/console-time-in-universe-tick.png"><img src="../images/game-of-life/console-time-in-universe-tick.png" alt="Screenshot of a Universe::tick timer results" /></a></p>
<p>下一节需要<code>nightly</code>编译器。它是必需的，因为<a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">测试 feature(特性) </a>我们准备用于基准测试。我们将安装的另一个工具是<a href="https://github.com/BurntSushi/cargo-benchcmp">Cargo benchcmp</a>。它是一个小实用程序，用于比较<code>cargo bench</code>生成的微基准测试。</p>
<p>一个<code>#[bench]</code>原生代码，就做了我们 WebAssembly 正在做的事情，但我们可以使用更成熟的分析工具。这是新的<code>wasm-game-of-life/benches/bench.rs</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(test)]

#fn main() {
extern crate test;
extern crate wasm_game_of_life;

#[bench]
fn universe_ticks(b: &amp;mut test::Bencher) {
    let mut universe = wasm_game_of_life::Universe::new();

    b.iter(|| {
        universe.tick();
    });
}
#}</code></pre></pre>
<p>我们还要注释所有的<code>#[wasm_bindgen]</code>标示，和来自<code>Cargo.toml</code>的<code>&quot;cdylib&quot;</code>，不然，构建本机代码将失败并出现链接错误。</p>
<p>有了这一切，我们就可以运行了<code>cargo bench | tee before.txt</code>编译并运行我们的基准测试！<code>| tee before.txt</code>部分将从<code>cargo bench</code>中获取输出，并放入一个名为<code>before.txt</code>的文件。</p>
<pre><code>$ cargo bench | tee before.txt
    Finished release [optimized + debuginfo] target(s) in 0.0 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>这也告诉我们二进制文件的位置，我们可以再次运行基准测试，但这次是在我们的操作系统的分析器下。就我而言，我正在运行 Linux，所以<a href="https://perf.wiki.kernel.org/index.php/Main_Page"><code>perf</code></a>是我将使用的探查分析器：</p>
<pre><code>$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench
running 1 test
test universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out

[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]
</code></pre>
<p>用<code>perf report</code>加载配置文件，表明我们所有的时间都花在了<code>Universe::tick</code>，如预期的那样：</p>
<p><a href="../images/game-of-life/bench-perf-report.png"><img src="../images/game-of-life/bench-perf-report.png" alt="Screenshot of perf report" /></a></p>
<p>如果你按<code>a</code>，工具<code>perf</code>将注释一个函数时间中的哪些命令的花费：</p>
<p><a href="../images/game-of-life/bench-perf-annotate.png"><img src="../images/game-of-life/bench-perf-annotate.png" alt="Screenshot of perf’s instruction annotation" /></a></p>
<p>这告诉我们 26.67％的时间用于求和相邻单元格的值，23.41％的时间用于获取邻居的列索引，另外 15.42％的时间用于获取邻居的行索引。在这三大最昂贵的命令中，第二和第三命令都让<code>div</code>很昂贵。这些<code>div</code>在<code>Universe::live_neighbor_count</code>实现 modulo 索引逻辑。</p>
<p>回想一下<code>wasm-game-of-life/src/lib.rs</code>里面的<code>live_neighbor_count</code>定义：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;
    for delta_row in [self.height - 1, 0, 1].iter().cloned() {
        for delta_col in [self.width - 1, 0, 1].iter().cloned() {
            if delta_row == 0 &amp;&amp; delta_col == 0 {
                continue;
            }

            let neighbor_row = (row + delta_row) % self.height;
            let neighbor_col = (column + delta_col) % self.width;
            let idx = self.get_index(neighbor_row, neighbor_col);
            count += self.cells[idx] as u8;
        }
    }
    count
}
#}</code></pre></pre>
<p>我们使用 modulo 的原因是为了避免使代码混乱，<code>if</code>出第一行或最后一行/列的边缘情况分支。但，当我们不在宇宙的边缘<code>row</code>或<code>column</code>的时候，不需要 modulo 包裹处理，会为此最常见情况的<code>div</code>命令付出代价。相反，如果我们使用<code>if</code>出边缘情况，并展开此循环，CPU 的分支预测器<em>应该</em>可以很好地预测它。</p>
<p>我们改写<code>live_neighbor_count</code>，像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;

    let north = if row == 0 {
        self.height - 1
    } else {
        row - 1
    };

    let south = if row == self.height - 1 {
        0
    } else {
        row + 1
    };

    let west = if column == 0 {
        self.width - 1
    } else {
        column - 1
    };

    let east = if column == self.width - 1 {
        0
    } else {
        column + 1
    };

    let nw = self.get_index(north, west);
    count += self.cells[nw] as u8;

    let n = self.get_index(north, column);
    count += self.cells[n] as u8;

    let ne = self.get_index(north, east);
    count += self.cells[ne] as u8;

    let w = self.get_index(row, west);
    count += self.cells[w] as u8;

    let e = self.get_index(row, east);
    count += self.cells[e] as u8;

    let sw = self.get_index(south, west);
    count += self.cells[sw] as u8;

    let s = self.get_index(south, column);
    count += self.cells[s] as u8;

    let se = self.get_index(south, east);
    count += self.cells[se] as u8;

    count
}
#}</code></pre></pre>
<p>现在让我们再次运行基准测试！这次输出到<code>after.txt</code>。</p>
<pre><code>$ cargo bench | tee after.txt
   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)
    Finished release [optimized + debuginfo] target(s) in 0.82 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>看起来好多了！我们可以看到它有多好，通过<code>benchcmp</code>工具，和比较我们之前创建的两个文本文件：</p>
<pre><code>$ cargo benchcmp before.txt after.txt
 name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup
 universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61
</code></pre>
<p>哇！7.61 倍的加速！</p>
<p>WebAssembly 有意映射到常见的硬件架构，但我们确实需要确保这个本机代码加速转换为 WebAssembly ，而 WebAssembly 当然也加快了速度。</p>
<p>让我们<code>wasm-pack build</code>，重建一下<code>.wasm</code>同并刷新<a href="http://localhost:8080/">http://localhost:8080 /</a>。在我的机器上，页面再次以每秒 60 帧的速度运行，并且使用浏览器的分析器记录另一个配置文件，显示每个动画帧大约需要 10 毫秒。</p>
<p>成功！</p>
<p><a href="../images/game-of-life/waterfall-after-branches-and-unrolling.png"><img src="../images/game-of-life/waterfall-after-branches-and-unrolling.png" alt="Screenshot of a waterfall view of rendering a frame after replacing modulos with branches" /></a></p>
<a class="header" href="#a演习" id="a演习"><h2>演习</h2></a>
<ul>
<li>
<p>在这一点上，下一个最低的强化是，<code>Universe::tick</code>删除分配和释放。实现单元格的双缓冲，其中<code>Universe</code>维护两个向量，从不释放它们中的任何一个，并且<code>tick</code>永远不会分配新的缓冲区。</p>
</li>
<li>
<p>从“实现生命”一章，实现替代的基于 delta 的设计，其中 Rust 代码返回，将状态更改为 JavaScript 的单元格列表。这会使渲染<code>&lt;canvas&gt;</code>快点？你可以实现这个设计，而不在每次 tick 上分配一个新的增量列表吗？</p>
</li>
<li>
<p>正如我们的分析向我们展示的那样，2D<code>&lt;canvas&gt;</code>渲染速度不是特别快。用 一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL 的</a>渲染器 替换 2D 画布渲染器。WebGL 版本的速度有多快？在 WebGL 渲染成为瓶颈之前，你能在多大程度上建立宇宙？</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../game-of-life/interactivity.zh.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../game-of-life/code-size.zh.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../game-of-life/interactivity.zh.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../game-of-life/code-size.zh.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-128555056-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
